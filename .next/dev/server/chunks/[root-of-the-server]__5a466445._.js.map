{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///home/deestarks/Desktop/landrop/lib/file-store.ts"],"sourcesContent":["import fs from \"fs/promises\";\nimport path from \"path\";\nimport { promisify } from \"util\";\nimport { gzip as zlibGzip } from \"zlib\";\n\nconst gzip = promisify(zlibGzip);\n\nexport interface FileItem {\n  id: string;\n  name: string;\n  originalName: string;\n  size: number;\n  compressedSize: number;\n  type: string;\n  folderId: string | null;\n  createdAt: Date;\n  data?: string; // base64 compressed data (optional now)\n}\n\nexport interface Folder {\n  id: string;\n  name: string;\n  parentId: string | null;\n  createdAt: Date;\n}\n\nconst ROOT_DIR = path.join(process.cwd(), \"uploads\");\n\n// Ensure root directory exists\nconst ensureRoot = async () => {\n  try {\n    await fs.access(ROOT_DIR);\n  } catch {\n    await fs.mkdir(ROOT_DIR, { recursive: true });\n  }\n};\n\nensureRoot();\n\nexport async function getFiles(folderId: string | null): Promise<FileItem[]> {\n  await ensureRoot();\n  const targetDir = folderId ? path.join(ROOT_DIR, folderId) : ROOT_DIR;\n\n  try {\n    const entries = await fs.readdir(targetDir, { withFileTypes: true });\n    const files: FileItem[] = [];\n\n    for (const entry of entries) {\n      if (entry.isFile() && entry.name.endsWith(\".json\")) {\n        const content = await fs.readFile(\n          path.join(targetDir, entry.name),\n          \"utf-8\"\n        );\n        try {\n          const fileData = JSON.parse(content);\n          // Ensure id is relative path from ROOT_DIR\n          const relativePath = path.relative(\n            ROOT_DIR,\n            path.join(targetDir, entry.name.replace(\".json\", \"\"))\n          );\n          files.push({ ...fileData, id: relativePath });\n        } catch (e) {\n          console.error(`Error parsing file metadata: ${entry.name}`, e);\n        }\n      }\n    }\n    return files;\n  } catch (e) {\n    console.error(\"Error reading directory:\", e);\n    return [];\n  }\n}\n\nexport async function getAllFiles(): Promise<FileItem[]> {\n  return getFiles(null);\n}\n\nexport async function getFile(id: string): Promise<FileItem | undefined> {\n  await ensureRoot();\n  const metaPath = path.join(ROOT_DIR, id + \".json\");\n  try {\n    const content = await fs.readFile(metaPath, \"utf-8\");\n    const fileData = JSON.parse(content);\n    return { ...fileData, id };\n  } catch {\n    return undefined;\n  }\n}\n\nexport async function addFile(file: FileItem, buffer: Buffer): Promise<void> {\n  await ensureRoot();\n  const targetDir = file.folderId\n    ? path.join(ROOT_DIR, file.folderId)\n    : ROOT_DIR;\n\n  // Ensure target directory exists\n  try {\n    await fs.access(targetDir);\n  } catch {\n    await fs.mkdir(targetDir, { recursive: true });\n  }\n\n  // Compress data\n  const compressedBuffer = await gzip(buffer);\n  file.compressedSize = compressedBuffer.length;\n\n  const filePath = path.join(targetDir, file.name);\n  const metaPath = path.join(targetDir, file.name + \".json\");\n\n  await fs.writeFile(filePath, compressedBuffer);\n  await fs.writeFile(metaPath, JSON.stringify(file, null, 2));\n}\n\nexport async function deleteFile(id: string): Promise<boolean> {\n  await ensureRoot();\n  const filePath = path.join(ROOT_DIR, id);\n  const metaPath = path.join(ROOT_DIR, id + \".json\");\n\n  try {\n    await fs.unlink(filePath);\n    await fs.unlink(metaPath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function getFolders(parentId: string | null): Promise<Folder[]> {\n  await ensureRoot();\n  const targetDir = parentId ? path.join(ROOT_DIR, parentId) : ROOT_DIR;\n\n  try {\n    const entries = await fs.readdir(targetDir, { withFileTypes: true });\n    const folders: Folder[] = [];\n\n    for (const entry of entries) {\n      if (entry.isDirectory()) {\n        const folderPath = path.join(targetDir, entry.name);\n        const relativePath = path.relative(ROOT_DIR, folderPath);\n        folders.push({\n          id: relativePath,\n          name: entry.name,\n          parentId: parentId,\n          createdAt: new Date(),\n        });\n      }\n    }\n    return folders;\n  } catch {\n    return [];\n  }\n}\n\nexport async function getFolder(id: string): Promise<Folder | undefined> {\n  await ensureRoot();\n  const folderPath = path.join(ROOT_DIR, id);\n  try {\n    await fs.access(folderPath);\n    return {\n      id,\n      name: path.basename(id),\n      parentId: path.dirname(id) === \".\" ? null : path.dirname(id),\n      createdAt: new Date(),\n    };\n  } catch {\n    return undefined;\n  }\n}\n\nexport async function addFolder(folder: Folder): Promise<void> {\n  await ensureRoot();\n  const targetDir = folder.parentId\n    ? path.join(ROOT_DIR, folder.parentId, folder.name)\n    : path.join(ROOT_DIR, folder.name);\n  await fs.mkdir(targetDir, { recursive: true });\n}\n\nexport async function deleteFolder(id: string): Promise<boolean> {\n  await ensureRoot();\n  const folderPath = path.join(ROOT_DIR, id);\n  try {\n    await fs.rm(folderPath, { recursive: true, force: true });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function getBreadcrumbs(folderId: string): Promise<Folder[]> {\n  const breadcrumbs: Folder[] = [];\n  let currentId: string | null = folderId;\n\n  while (currentId) {\n    const folder = await getFolder(currentId);\n    if (folder) {\n      breadcrumbs.unshift(folder);\n      currentId = folder.parentId;\n    } else {\n      break;\n    }\n  }\n\n  return breadcrumbs;\n}\n\nexport async function searchFiles(query: string): Promise<FileItem[]> {\n  await ensureRoot();\n  const results: FileItem[] = [];\n\n  async function searchDir(dir: string) {\n    const entries = await fs.readdir(dir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = path.join(dir, entry.name);\n      if (entry.isDirectory()) {\n        await searchDir(fullPath);\n      } else if (entry.isFile() && entry.name.endsWith(\".json\")) {\n        try {\n          const content = await fs.readFile(fullPath, \"utf-8\");\n          const fileData = JSON.parse(content);\n          if (fileData.name.toLowerCase().includes(query.toLowerCase())) {\n            const relativePath = path.relative(\n              ROOT_DIR,\n              fullPath.replace(\".json\", \"\")\n            );\n            results.push({ ...fileData, id: relativePath });\n          }\n        } catch (e) {\n          console.error(\n            `Error parsing file metadata during search: ${entry.name}`,\n            e\n          );\n        }\n      }\n    }\n  }\n\n  await searchDir(ROOT_DIR);\n  return results;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,OAAO,IAAA,8GAAS,EAAC,yGAAQ;AAqB/B,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;AAE1C,+BAA+B;AAC/B,MAAM,aAAa;IACjB,IAAI;QACF,MAAM,gIAAE,CAAC,MAAM,CAAC;IAClB,EAAE,OAAM;QACN,MAAM,gIAAE,CAAC,KAAK,CAAC,UAAU;YAAE,WAAW;QAAK;IAC7C;AACF;AAEA;AAEO,eAAe,SAAS,QAAuB;IACpD,MAAM;IACN,MAAM,YAAY,WAAW,4GAAI,CAAC,IAAI,CAAC,UAAU,YAAY;IAE7D,IAAI;QACF,MAAM,UAAU,MAAM,gIAAE,CAAC,OAAO,CAAC,WAAW;YAAE,eAAe;QAAK;QAClE,MAAM,QAAoB,EAAE;QAE5B,KAAK,MAAM,SAAS,QAAS;YAC3B,IAAI,MAAM,MAAM,MAAM,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU;gBAClD,MAAM,UAAU,MAAM,gIAAE,CAAC,QAAQ,CAC/B,4GAAI,CAAC,IAAI,CAAC,WAAW,MAAM,IAAI,GAC/B;gBAEF,IAAI;oBACF,MAAM,WAAW,KAAK,KAAK,CAAC;oBAC5B,2CAA2C;oBAC3C,MAAM,eAAe,4GAAI,CAAC,QAAQ,CAChC,UACA,4GAAI,CAAC,IAAI,CAAC,WAAW,MAAM,IAAI,CAAC,OAAO,CAAC,SAAS;oBAEnD,MAAM,IAAI,CAAC;wBAAE,GAAG,QAAQ;wBAAE,IAAI;oBAAa;gBAC7C,EAAE,OAAO,GAAG;oBACV,QAAQ,KAAK,CAAC,CAAC,6BAA6B,EAAE,MAAM,IAAI,EAAE,EAAE;gBAC9D;YACF;QACF;QACA,OAAO;IACT,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,EAAE;IACX;AACF;AAEO,eAAe;IACpB,OAAO,SAAS;AAClB;AAEO,eAAe,QAAQ,EAAU;IACtC,MAAM;IACN,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,UAAU,KAAK;IAC1C,IAAI;QACF,MAAM,UAAU,MAAM,gIAAE,CAAC,QAAQ,CAAC,UAAU;QAC5C,MAAM,WAAW,KAAK,KAAK,CAAC;QAC5B,OAAO;YAAE,GAAG,QAAQ;YAAE;QAAG;IAC3B,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,QAAQ,IAAc,EAAE,MAAc;IAC1D,MAAM;IACN,MAAM,YAAY,KAAK,QAAQ,GAC3B,4GAAI,CAAC,IAAI,CAAC,UAAU,KAAK,QAAQ,IACjC;IAEJ,iCAAiC;IACjC,IAAI;QACF,MAAM,gIAAE,CAAC,MAAM,CAAC;IAClB,EAAE,OAAM;QACN,MAAM,gIAAE,CAAC,KAAK,CAAC,WAAW;YAAE,WAAW;QAAK;IAC9C;IAEA,gBAAgB;IAChB,MAAM,mBAAmB,MAAM,KAAK;IACpC,KAAK,cAAc,GAAG,iBAAiB,MAAM;IAE7C,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,WAAW,KAAK,IAAI;IAC/C,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,WAAW,KAAK,IAAI,GAAG;IAElD,MAAM,gIAAE,CAAC,SAAS,CAAC,UAAU;IAC7B,MAAM,gIAAE,CAAC,SAAS,CAAC,UAAU,KAAK,SAAS,CAAC,MAAM,MAAM;AAC1D;AAEO,eAAe,WAAW,EAAU;IACzC,MAAM;IACN,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,UAAU;IACrC,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,UAAU,KAAK;IAE1C,IAAI;QACF,MAAM,gIAAE,CAAC,MAAM,CAAC;QAChB,MAAM,gIAAE,CAAC,MAAM,CAAC;QAChB,OAAO;IACT,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,WAAW,QAAuB;IACtD,MAAM;IACN,MAAM,YAAY,WAAW,4GAAI,CAAC,IAAI,CAAC,UAAU,YAAY;IAE7D,IAAI;QACF,MAAM,UAAU,MAAM,gIAAE,CAAC,OAAO,CAAC,WAAW;YAAE,eAAe;QAAK;QAClE,MAAM,UAAoB,EAAE;QAE5B,KAAK,MAAM,SAAS,QAAS;YAC3B,IAAI,MAAM,WAAW,IAAI;gBACvB,MAAM,aAAa,4GAAI,CAAC,IAAI,CAAC,WAAW,MAAM,IAAI;gBAClD,MAAM,eAAe,4GAAI,CAAC,QAAQ,CAAC,UAAU;gBAC7C,QAAQ,IAAI,CAAC;oBACX,IAAI;oBACJ,MAAM,MAAM,IAAI;oBAChB,UAAU;oBACV,WAAW,IAAI;gBACjB;YACF;QACF;QACA,OAAO;IACT,EAAE,OAAM;QACN,OAAO,EAAE;IACX;AACF;AAEO,eAAe,UAAU,EAAU;IACxC,MAAM;IACN,MAAM,aAAa,4GAAI,CAAC,IAAI,CAAC,UAAU;IACvC,IAAI;QACF,MAAM,gIAAE,CAAC,MAAM,CAAC;QAChB,OAAO;YACL;YACA,MAAM,4GAAI,CAAC,QAAQ,CAAC;YACpB,UAAU,4GAAI,CAAC,OAAO,CAAC,QAAQ,MAAM,OAAO,4GAAI,CAAC,OAAO,CAAC;YACzD,WAAW,IAAI;QACjB;IACF,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,UAAU,MAAc;IAC5C,MAAM;IACN,MAAM,YAAY,OAAO,QAAQ,GAC7B,4GAAI,CAAC,IAAI,CAAC,UAAU,OAAO,QAAQ,EAAE,OAAO,IAAI,IAChD,4GAAI,CAAC,IAAI,CAAC,UAAU,OAAO,IAAI;IACnC,MAAM,gIAAE,CAAC,KAAK,CAAC,WAAW;QAAE,WAAW;IAAK;AAC9C;AAEO,eAAe,aAAa,EAAU;IAC3C,MAAM;IACN,MAAM,aAAa,4GAAI,CAAC,IAAI,CAAC,UAAU;IACvC,IAAI;QACF,MAAM,gIAAE,CAAC,EAAE,CAAC,YAAY;YAAE,WAAW;YAAM,OAAO;QAAK;QACvD,OAAO;IACT,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,eAAe,QAAgB;IACnD,MAAM,cAAwB,EAAE;IAChC,IAAI,YAA2B;IAE/B,MAAO,UAAW;QAChB,MAAM,SAAS,MAAM,UAAU;QAC/B,IAAI,QAAQ;YACV,YAAY,OAAO,CAAC;YACpB,YAAY,OAAO,QAAQ;QAC7B,OAAO;YACL;QACF;IACF;IAEA,OAAO;AACT;AAEO,eAAe,YAAY,KAAa;IAC7C,MAAM;IACN,MAAM,UAAsB,EAAE;IAE9B,eAAe,UAAU,GAAW;QAClC,MAAM,UAAU,MAAM,gIAAE,CAAC,OAAO,CAAC,KAAK;YAAE,eAAe;QAAK;QAE5D,KAAK,MAAM,SAAS,QAAS;YAC3B,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,KAAK,MAAM,IAAI;YAC1C,IAAI,MAAM,WAAW,IAAI;gBACvB,MAAM,UAAU;YAClB,OAAO,IAAI,MAAM,MAAM,MAAM,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU;gBACzD,IAAI;oBACF,MAAM,UAAU,MAAM,gIAAE,CAAC,QAAQ,CAAC,UAAU;oBAC5C,MAAM,WAAW,KAAK,KAAK,CAAC;oBAC5B,IAAI,SAAS,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,MAAM,WAAW,KAAK;wBAC7D,MAAM,eAAe,4GAAI,CAAC,QAAQ,CAChC,UACA,SAAS,OAAO,CAAC,SAAS;wBAE5B,QAAQ,IAAI,CAAC;4BAAE,GAAG,QAAQ;4BAAE,IAAI;wBAAa;oBAC/C;gBACF,EAAE,OAAO,GAAG;oBACV,QAAQ,KAAK,CACX,CAAC,2CAA2C,EAAE,MAAM,IAAI,EAAE,EAC1D;gBAEJ;YACF;QACF;IACF;IAEA,MAAM,UAAU;IAChB,OAAO;AACT"}},
    {"offset": {"line": 302, "column": 0}, "map": {"version":3,"sources":["file:///home/deestarks/Desktop/landrop/app/api/files/%5Bid%5D/route.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from \"next/server\";\nimport { getFile, deleteFile } from \"@/lib/file-store\";\nimport { decompressData, base64ToUint8Array } from \"@/lib/compression\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\nimport { promisify } from \"util\";\nimport { gunzip as zlibGunzip } from \"zlib\";\n\nconst gunzip = promisify(zlibGunzip);\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  const { id } = await params;\n  const file = await getFile(id);\n\n  if (!file) {\n    return NextResponse.json({ error: \"File not found\" }, { status: 404 });\n  }\n\n  // Read the compressed file directly\n  const filePath = path.join(process.cwd(), \"uploads\", id);\n\n  try {\n    const fileBuffer = await fs.readFile(filePath);\n    const decompressedBuffer = await gunzip(fileBuffer);\n\n    return new NextResponse(decompressedBuffer, {\n      headers: {\n        \"Content-Type\": file.type,\n        \"Content-Disposition\": `attachment; filename=\"${encodeURIComponent(\n          file.originalName\n        )}\"`,\n        \"Content-Length\": decompressedBuffer.length.toString(),\n      },\n    });\n  } catch (e) {\n    console.error(\"Error reading/decompressing file:\", e);\n    return NextResponse.json({ error: \"Failed to read file\" }, { status: 500 });\n  }\n}\n\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  const { id } = await params;\n  const success = deleteFile(id);\n\n  if (!success) {\n    return NextResponse.json({ error: \"File not found\" }, { status: 404 });\n  }\n\n  return NextResponse.json({ success: true });\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAEA;AACA;AACA;AACA;;;;;;;AAEA,MAAM,SAAS,IAAA,8GAAS,EAAC,2GAAU;AAE5B,eAAe,IACpB,OAAoB,EACpB,EAAE,MAAM,EAAuC;IAE/C,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;IACrB,MAAM,OAAO,MAAM,IAAA,4IAAO,EAAC;IAE3B,IAAI,CAAC,MAAM;QACT,OAAO,2JAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAiB,GAAG;YAAE,QAAQ;QAAI;IACtE;IAEA,oCAAoC;IACpC,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,WAAW;IAErD,IAAI;QACF,MAAM,aAAa,MAAM,gIAAE,CAAC,QAAQ,CAAC;QACrC,MAAM,qBAAqB,MAAM,OAAO;QAExC,OAAO,IAAI,2JAAY,CAAC,oBAAoB;YAC1C,SAAS;gBACP,gBAAgB,KAAK,IAAI;gBACzB,uBAAuB,CAAC,sBAAsB,EAAE,mBAC9C,KAAK,YAAY,EACjB,CAAC,CAAC;gBACJ,kBAAkB,mBAAmB,MAAM,CAAC,QAAQ;YACtD;QACF;IACF,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC,qCAAqC;QACnD,OAAO,2JAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAsB,GAAG;YAAE,QAAQ;QAAI;IAC3E;AACF;AAEO,eAAe,OACpB,OAAoB,EACpB,EAAE,MAAM,EAAuC;IAE/C,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;IACrB,MAAM,UAAU,IAAA,+IAAU,EAAC;IAE3B,IAAI,CAAC,SAAS;QACZ,OAAO,2JAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAiB,GAAG;YAAE,QAAQ;QAAI;IACtE;IAEA,OAAO,2JAAY,CAAC,IAAI,CAAC;QAAE,SAAS;IAAK;AAC3C"}}]
}