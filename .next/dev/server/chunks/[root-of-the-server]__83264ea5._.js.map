{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///home/deestarks/Desktop/landrop/lib/file-store.ts"],"sourcesContent":["import fs from \"fs/promises\";\nimport path from \"path\";\nimport { existsSync } from \"fs\";\n\nexport interface FileItem {\n  id: string;\n  name: string;\n  originalName: string;\n  size: number;\n  compressedSize: number;\n  type: string;\n  folderId: string | null;\n  createdAt: Date;\n}\n\nexport interface Folder {\n  id: string;\n  name: string;\n  parentId: string | null;\n  createdAt: Date;\n}\n\nconst ROOT_DIR = path.join(process.cwd(), \"uploads\");\n\nif (!existsSync(ROOT_DIR)) {\n  fs.mkdir(ROOT_DIR, { recursive: true }).catch(console.error);\n}\n\nfunction getAbsolutePath(relativePath: string | null): string {\n  if (!relativePath || relativePath === \"root\") {\n    return ROOT_DIR;\n  }\n  const safePath = path.normalize(relativePath).replace(/^(\\.\\.[\\/\\\\])+/, \"\");\n  return path.join(ROOT_DIR, safePath);\n}\n\nfunction getRelativePath(absolutePath: string): string {\n  const relative = path.relative(ROOT_DIR, absolutePath);\n  return relative === \"\" ? \"root\" : relative;\n}\n\nexport async function getFiles(\n  folderId: string | null = null\n): Promise<FileItem[]> {\n  const dirPath = getAbsolutePath(folderId);\n\n  try {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\n    const files: FileItem[] = [];\n\n    for (const entry of entries) {\n      if (entry.isFile()) {\n        const stats = await fs.stat(path.join(dirPath, entry.name));\n        files.push({\n          id: getRelativePath(path.join(dirPath, entry.name)),\n          name: entry.name,\n          originalName: entry.name,\n          size: stats.size,\n          compressedSize: stats.size, // no compression for now\n          type: \"application/octet-stream\", // TODO: detect mime type\n          folderId: folderId === \"root\" ? null : folderId,\n          createdAt: stats.birthtime,\n        });\n      }\n    }\n\n    return files.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n  } catch (error) {\n    console.error(\"Error reading files:\", error);\n    return [];\n  }\n}\n\nexport async function getAllFiles(): Promise<FileItem[]> {\n  async function traverse(dir: string): Promise<FileItem[]> {\n    const entries = await fs.readdir(dir, { withFileTypes: true });\n    let results: FileItem[] = [];\n\n    for (const entry of entries) {\n      const fullPath = path.join(dir, entry.name);\n      if (entry.isDirectory()) {\n        results = results.concat(await traverse(fullPath));\n      } else {\n        const stats = await fs.stat(fullPath);\n        results.push({\n          id: getRelativePath(fullPath),\n          name: entry.name,\n          originalName: entry.name,\n          size: stats.size,\n          compressedSize: stats.size,\n          type: \"application/octet-stream\",\n          folderId:\n            getRelativePath(dir) === \"root\" ? null : getRelativePath(dir),\n          createdAt: stats.birthtime,\n        });\n      }\n    }\n    return results;\n  }\n\n  try {\n    const files = await traverse(ROOT_DIR);\n    return files.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n  } catch (error) {\n    console.error(\"Error getting all files:\", error);\n    return [];\n  }\n}\n\nexport async function getFile(id: string): Promise<FileItem | undefined> {\n  const filePath = getAbsolutePath(id);\n  try {\n    const stats = await fs.stat(filePath);\n    return {\n      id: id,\n      name: path.basename(id),\n      originalName: path.basename(id),\n      size: stats.size,\n      compressedSize: stats.size,\n      type: \"application/octet-stream\",\n      folderId:\n        getRelativePath(path.dirname(filePath)) === \"root\"\n          ? null\n          : getRelativePath(path.dirname(filePath)),\n      createdAt: stats.birthtime,\n    };\n  } catch {\n    return undefined;\n  }\n}\n\nexport async function addFile(file: FileItem, buffer: Buffer): Promise<void> {\n  const folderPath = getAbsolutePath(file.folderId);\n  const filePath = path.join(folderPath, file.name);\n  await fs.writeFile(filePath, buffer);\n}\n\nexport async function deleteFile(id: string): Promise<boolean> {\n  try {\n    await fs.unlink(getAbsolutePath(id));\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function getFolders(\n  parentId: string | null = null\n): Promise<Folder[]> {\n  const dirPath = getAbsolutePath(parentId);\n\n  try {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\n    const folders: Folder[] = [];\n\n    for (const entry of entries) {\n      if (entry.isDirectory()) {\n        const stats = await fs.stat(path.join(dirPath, entry.name));\n        folders.push({\n          id: getRelativePath(path.join(dirPath, entry.name)),\n          name: entry.name,\n          parentId: parentId === \"root\" ? null : parentId,\n          createdAt: stats.birthtime,\n        });\n      }\n    }\n\n    return folders.sort((a, b) => a.name.localeCompare(b.name));\n  } catch (error) {\n    console.error(\"Error reading folders:\", error);\n    return [];\n  }\n}\n\nexport async function getFolder(id: string): Promise<Folder | undefined> {\n  const folderPath = getAbsolutePath(id);\n  try {\n    const stats = await fs.stat(folderPath);\n    if (!stats.isDirectory()) return undefined;\n\n    return {\n      id: id,\n      name: path.basename(id),\n      parentId:\n        getRelativePath(path.dirname(folderPath)) === \"root\"\n          ? null\n          : getRelativePath(path.dirname(folderPath)),\n      createdAt: stats.birthtime,\n    };\n  } catch {\n    return undefined;\n  }\n}\n\nexport async function addFolder(folder: Folder): Promise<void> {\n  const parentPath = getAbsolutePath(folder.parentId);\n  const folderPath = path.join(parentPath, folder.name);\n  await fs.mkdir(folderPath, { recursive: true });\n}\n\nexport async function deleteFolder(id: string): Promise<boolean> {\n  try {\n    await fs.rm(getAbsolutePath(id), { recursive: true, force: true });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function getBreadcrumbs(\n  folderId: string | null\n): Promise<Folder[]> {\n  const breadcrumbs: Folder[] = [];\n  if (!folderId || folderId === \"root\") return breadcrumbs;\n\n  let currentPath = folderId;\n\n  while (currentPath && currentPath !== \"root\") {\n    const folder = await getFolder(currentPath);\n    if (folder) {\n      breadcrumbs.unshift(folder);\n      const parentDir = path.dirname(currentPath);\n      currentPath = parentDir === \".\" ? \"root\" : parentDir;\n    } else {\n      break;\n    }\n  }\n\n  return breadcrumbs;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 279, "column": 0}, "map": {"version":3,"sources":["file:///home/deestarks/Desktop/landrop/app/api/files/route.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from \"next/server\";\nimport {\n  addFile,\n  getFiles,\n  getAllFiles,\n  type FileItem,\n} from \"@/lib/file-store\";\n\nexport const dynamic = \"force-dynamic\";\n\nexport async function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams;\n  const folderId = searchParams.get(\"folderId\");\n\n  const files =\n    folderId === \"all\" ? await getAllFiles() : await getFiles(folderId);\n\n  return NextResponse.json(files);\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const formData = await request.formData();\n    const file = formData.get(\"file\") as File;\n    const folderId = formData.get(\"folderId\") as string | null;\n\n    if (!file) {\n      return NextResponse.json({ error: \"No file provided\" }, { status: 400 });\n    }\n\n    const arrayBuffer = await file.arrayBuffer();\n    const buffer = Buffer.from(arrayBuffer);\n\n    const fileItem: FileItem = {\n      id: \"\",\n      name: file.name,\n      originalName: file.name,\n      size: file.size,\n      compressedSize: file.size,\n      type: file.type || \"application/octet-stream\",\n      folderId: folderId || null,\n      createdAt: new Date(),\n    };\n\n    await addFile(fileItem, buffer);\n\n    return NextResponse.json(fileItem);\n  } catch (e) {\n    console.error(e);\n    return NextResponse.json(\n      { error: \"Failed to upload file\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAOO,MAAM,UAAU;AAEhB,eAAe,IAAI,OAAoB;IAC5C,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;IACjD,MAAM,WAAW,aAAa,GAAG,CAAC;IAElC,MAAM,QACJ,aAAa,QAAQ,MAAM,IAAA,gJAAW,MAAK,MAAM,IAAA,6IAAQ,EAAC;IAE5D,OAAO,2JAAY,CAAC,IAAI,CAAC;AAC3B;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,OAAO,SAAS,GAAG,CAAC;QAC1B,MAAM,WAAW,SAAS,GAAG,CAAC;QAE9B,IAAI,CAAC,MAAM;YACT,OAAO,2JAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAmB,GAAG;gBAAE,QAAQ;YAAI;QACxE;QAEA,MAAM,cAAc,MAAM,KAAK,WAAW;QAC1C,MAAM,SAAS,OAAO,IAAI,CAAC;QAE3B,MAAM,WAAqB;YACzB,IAAI;YACJ,MAAM,KAAK,IAAI;YACf,cAAc,KAAK,IAAI;YACvB,MAAM,KAAK,IAAI;YACf,gBAAgB,KAAK,IAAI;YACzB,MAAM,KAAK,IAAI,IAAI;YACnB,UAAU,YAAY;YACtB,WAAW,IAAI;QACjB;QAEA,MAAM,IAAA,4IAAO,EAAC,UAAU;QAExB,OAAO,2JAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC;QACd,OAAO,2JAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}