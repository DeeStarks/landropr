{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///home/deestarks/Desktop/landrop/lib/file-store.ts"],"sourcesContent":["import fs from \"fs/promises\";\nimport path from \"path\";\nimport { promisify } from \"util\";\nimport { gzip as zlibGzip } from \"zlib\";\n\nconst gzip = promisify(zlibGzip);\n\nexport interface FileItem {\n  id: string;\n  name: string;\n  originalName: string;\n  size: number;\n  compressedSize: number;\n  type: string;\n  folderId: string | null;\n  createdAt: Date;\n  data?: string; // base64 compressed data (optional now)\n}\n\nexport interface Folder {\n  id: string;\n  name: string;\n  parentId: string | null;\n  createdAt: Date;\n}\n\nconst ROOT_DIR = path.join(process.cwd(), \"uploads\");\n\n// Ensure root directory exists\nconst ensureRoot = async () => {\n  try {\n    await fs.access(ROOT_DIR);\n  } catch {\n    await fs.mkdir(ROOT_DIR, { recursive: true });\n  }\n};\n\nensureRoot();\n\nexport async function getFiles(folderId: string | null): Promise<FileItem[]> {\n  await ensureRoot();\n  const targetDir = folderId ? path.join(ROOT_DIR, folderId) : ROOT_DIR;\n\n  try {\n    const entries = await fs.readdir(targetDir, { withFileTypes: true });\n    const files: FileItem[] = [];\n\n    for (const entry of entries) {\n      if (entry.isFile() && entry.name.endsWith(\".json\")) {\n        const content = await fs.readFile(\n          path.join(targetDir, entry.name),\n          \"utf-8\"\n        );\n        try {\n          const fileData = JSON.parse(content);\n          // Ensure id is relative path from ROOT_DIR\n          const relativePath = path.relative(\n            ROOT_DIR,\n            path.join(targetDir, entry.name.replace(\".json\", \"\"))\n          );\n          files.push({ ...fileData, id: relativePath });\n        } catch (e) {\n          console.error(`Error parsing file metadata: ${entry.name}`, e);\n        }\n      }\n    }\n    return files;\n  } catch (e) {\n    console.error(\"Error reading directory:\", e);\n    return [];\n  }\n}\n\nexport async function getAllFiles(): Promise<FileItem[]> {\n  return getFiles(null);\n}\n\nexport async function getFile(id: string): Promise<FileItem | undefined> {\n  await ensureRoot();\n  const metaPath = path.join(ROOT_DIR, id + \".json\");\n  try {\n    const content = await fs.readFile(metaPath, \"utf-8\");\n    const fileData = JSON.parse(content);\n    return { ...fileData, id };\n  } catch {\n    return undefined;\n  }\n}\n\nexport async function addFile(file: FileItem, buffer: Buffer): Promise<void> {\n  await ensureRoot();\n  const targetDir = file.folderId\n    ? path.join(ROOT_DIR, file.folderId)\n    : ROOT_DIR;\n\n  // Ensure target directory exists\n  try {\n    await fs.access(targetDir);\n  } catch {\n    await fs.mkdir(targetDir, { recursive: true });\n  }\n\n  // Compress data\n  const compressedBuffer = await gzip(buffer);\n  file.compressedSize = compressedBuffer.length;\n\n  const filePath = path.join(targetDir, file.name);\n  const metaPath = path.join(targetDir, file.name + \".json\");\n\n  await fs.writeFile(filePath, compressedBuffer);\n  await fs.writeFile(metaPath, JSON.stringify(file, null, 2));\n}\n\nexport async function deleteFile(id: string): Promise<boolean> {\n  await ensureRoot();\n  const filePath = path.join(ROOT_DIR, id);\n  const metaPath = path.join(ROOT_DIR, id + \".json\");\n\n  try {\n    await fs.unlink(filePath);\n    await fs.unlink(metaPath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function getFolders(parentId: string | null): Promise<Folder[]> {\n  await ensureRoot();\n  const targetDir = parentId ? path.join(ROOT_DIR, parentId) : ROOT_DIR;\n\n  try {\n    const entries = await fs.readdir(targetDir, { withFileTypes: true });\n    const folders: Folder[] = [];\n\n    for (const entry of entries) {\n      if (entry.isDirectory()) {\n        const folderPath = path.join(targetDir, entry.name);\n        const relativePath = path.relative(ROOT_DIR, folderPath);\n        folders.push({\n          id: relativePath,\n          name: entry.name,\n          parentId: parentId,\n          createdAt: new Date(),\n        });\n      }\n    }\n    return folders;\n  } catch {\n    return [];\n  }\n}\n\nexport async function getFolder(id: string): Promise<Folder | undefined> {\n  await ensureRoot();\n  const folderPath = path.join(ROOT_DIR, id);\n  try {\n    await fs.access(folderPath);\n    return {\n      id,\n      name: path.basename(id),\n      parentId: path.dirname(id) === \".\" ? null : path.dirname(id),\n      createdAt: new Date(),\n    };\n  } catch {\n    return undefined;\n  }\n}\n\nexport async function addFolder(folder: Folder): Promise<void> {\n  await ensureRoot();\n  const targetDir = folder.parentId\n    ? path.join(ROOT_DIR, folder.parentId, folder.name)\n    : path.join(ROOT_DIR, folder.name);\n  await fs.mkdir(targetDir, { recursive: true });\n}\n\nexport async function deleteFolder(id: string): Promise<boolean> {\n  await ensureRoot();\n  const folderPath = path.join(ROOT_DIR, id);\n  try {\n    await fs.rm(folderPath, { recursive: true, force: true });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function getBreadcrumbs(folderId: string): Promise<Folder[]> {\n  const breadcrumbs: Folder[] = [];\n  let currentId: string | null = folderId;\n\n  while (currentId) {\n    const folder = await getFolder(currentId);\n    if (folder) {\n      breadcrumbs.unshift(folder);\n      currentId = folder.parentId;\n    } else {\n      break;\n    }\n  }\n\n  return breadcrumbs;\n}\n\nexport async function searchFiles(query: string): Promise<FileItem[]> {\n  await ensureRoot();\n  const results: FileItem[] = [];\n\n  async function searchDir(dir: string) {\n    const entries = await fs.readdir(dir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = path.join(dir, entry.name);\n      if (entry.isDirectory()) {\n        await searchDir(fullPath);\n      } else if (entry.isFile() && entry.name.endsWith(\".json\")) {\n        try {\n          const content = await fs.readFile(fullPath, \"utf-8\");\n          const fileData = JSON.parse(content);\n          if (fileData.name.toLowerCase().includes(query.toLowerCase())) {\n            const relativePath = path.relative(\n              ROOT_DIR,\n              fullPath.replace(\".json\", \"\")\n            );\n            results.push({ ...fileData, id: relativePath });\n          }\n        } catch (e) {\n          console.error(\n            `Error parsing file metadata during search: ${entry.name}`,\n            e\n          );\n        }\n      }\n    }\n  }\n\n  await searchDir(ROOT_DIR);\n  return results;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 302, "column": 0}, "map": {"version":3,"sources":["file:///home/deestarks/Desktop/landrop/app/api/files/route.ts"],"sourcesContent":["export const dynamic = \"force-dynamic\";\n\nimport { type NextRequest, NextResponse } from \"next/server\";\nimport { getFiles, addFile, searchFiles } from \"@/lib/file-store\";\nimport type { FileItem } from \"@/lib/file-store\";\n\nexport async function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams;\n  const folderId = searchParams.get(\"folderId\");\n  const searchQuery = searchParams.get(\"search\");\n\n  if (searchQuery) {\n    const files = await searchFiles(searchQuery);\n    return NextResponse.json(files);\n  }\n\n  const files = await getFiles(folderId || null);\n  return NextResponse.json(files);\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const formData = await request.formData();\n    const file = formData.get(\"file\") as File;\n    const folderId = formData.get(\"folderId\") as string | null;\n\n    if (!file) {\n      return NextResponse.json({ error: \"No file provided\" }, { status: 400 });\n    }\n\n    const arrayBuffer = await file.arrayBuffer();\n    const buffer = Buffer.from(arrayBuffer);\n\n    const fileItem: FileItem = {\n      id: \"\", // Will be set by logic\n      name: file.name,\n      originalName: file.name,\n      size: file.size,\n      compressedSize: 0, // Will be set by addFile\n      type: file.type || \"application/octet-stream\",\n      folderId: folderId || null,\n      createdAt: new Date(),\n    };\n\n    await addFile(fileItem, buffer);\n\n    return NextResponse.json(fileItem);\n  } catch (e) {\n    console.error(e);\n    return NextResponse.json(\n      { error: \"Failed to upload file\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAEA;AACA;AAHO,MAAM,UAAU;;;AAMhB,eAAe,IAAI,OAAoB;IAC5C,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;IACjD,MAAM,WAAW,aAAa,GAAG,CAAC;IAClC,MAAM,cAAc,aAAa,GAAG,CAAC;IAErC,IAAI,aAAa;QACf,MAAM,QAAQ,MAAM,IAAA,gJAAW,EAAC;QAChC,OAAO,2JAAY,CAAC,IAAI,CAAC;IAC3B;IAEA,MAAM,QAAQ,MAAM,IAAA,6IAAQ,EAAC,YAAY;IACzC,OAAO,2JAAY,CAAC,IAAI,CAAC;AAC3B;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,OAAO,SAAS,GAAG,CAAC;QAC1B,MAAM,WAAW,SAAS,GAAG,CAAC;QAE9B,IAAI,CAAC,MAAM;YACT,OAAO,2JAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAmB,GAAG;gBAAE,QAAQ;YAAI;QACxE;QAEA,MAAM,cAAc,MAAM,KAAK,WAAW;QAC1C,MAAM,SAAS,OAAO,IAAI,CAAC;QAE3B,MAAM,WAAqB;YACzB,IAAI;YACJ,MAAM,KAAK,IAAI;YACf,cAAc,KAAK,IAAI;YACvB,MAAM,KAAK,IAAI;YACf,gBAAgB;YAChB,MAAM,KAAK,IAAI,IAAI;YACnB,UAAU,YAAY;YACtB,WAAW,IAAI;QACjB;QAEA,MAAM,IAAA,4IAAO,EAAC,UAAU;QAExB,OAAO,2JAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,GAAG;QACV,QAAQ,KAAK,CAAC;QACd,OAAO,2JAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}