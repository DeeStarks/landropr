{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///home/deestarks/Desktop/landrop/lib/file-store.ts"],"sourcesContent":["import fs from \"fs/promises\";\nimport path from \"path\";\nimport { existsSync } from \"fs\";\n\nexport interface FileItem {\n  id: string;\n  name: string;\n  originalName: string;\n  size: number;\n  compressedSize: number;\n  type: string;\n  folderId: string | null;\n  createdAt: Date;\n  data?: string; // base64 compressed data (optional now)\n}\n\nexport interface Folder {\n  id: string;\n  name: string;\n  parentId: string | null;\n  createdAt: Date;\n}\n\nconst ROOT_DIR = path.join(process.cwd(), \"uploads\");\n\n// Ensure root directory exists\nif (!existsSync(ROOT_DIR)) {\n  fs.mkdir(ROOT_DIR, { recursive: true }).catch(console.error);\n}\n\nfunction getAbsolutePath(relativePath: string | null): string {\n  if (!relativePath || relativePath === \"root\") {\n    return ROOT_DIR;\n  }\n  // Prevent directory traversal\n  const safePath = path.normalize(relativePath).replace(/^(\\.\\.[\\/\\\\])+/, \"\");\n  return path.join(ROOT_DIR, safePath);\n}\n\nfunction getRelativePath(absolutePath: string): string {\n  const relative = path.relative(ROOT_DIR, absolutePath);\n  return relative === \"\" ? \"root\" : relative;\n}\n\nexport async function getFiles(\n  folderId: string | null = null\n): Promise<FileItem[]> {\n  const dirPath = getAbsolutePath(folderId);\n\n  try {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\n    const files: FileItem[] = [];\n\n    for (const entry of entries) {\n      if (entry.isFile()) {\n        const stats = await fs.stat(path.join(dirPath, entry.name));\n        files.push({\n          id: getRelativePath(path.join(dirPath, entry.name)),\n          name: entry.name,\n          originalName: entry.name,\n          size: stats.size,\n          compressedSize: stats.size, // No compression for now\n          type: \"application/octet-stream\", // TODO: Detect mime type if needed\n          folderId: folderId === \"root\" ? null : folderId,\n          createdAt: stats.birthtime,\n        });\n      }\n    }\n\n    return files.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n  } catch (error) {\n    console.error(\"Error reading files:\", error);\n    return [];\n  }\n}\n\nexport async function getAllFiles(): Promise<FileItem[]> {\n  // Recursive function to get all files\n  async function traverse(dir: string): Promise<FileItem[]> {\n    const entries = await fs.readdir(dir, { withFileTypes: true });\n    let results: FileItem[] = [];\n\n    for (const entry of entries) {\n      const fullPath = path.join(dir, entry.name);\n      if (entry.isDirectory()) {\n        results = results.concat(await traverse(fullPath));\n      } else {\n        const stats = await fs.stat(fullPath);\n        results.push({\n          id: getRelativePath(fullPath),\n          name: entry.name,\n          originalName: entry.name,\n          size: stats.size,\n          compressedSize: stats.size,\n          type: \"application/octet-stream\",\n          folderId:\n            getRelativePath(dir) === \"root\" ? null : getRelativePath(dir),\n          createdAt: stats.birthtime,\n        });\n      }\n    }\n    return results;\n  }\n\n  try {\n    const files = await traverse(ROOT_DIR);\n    return files.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n  } catch (error) {\n    console.error(\"Error getting all files:\", error);\n    return [];\n  }\n}\n\nexport async function getFile(id: string): Promise<FileItem | undefined> {\n  const filePath = getAbsolutePath(id);\n  try {\n    const stats = await fs.stat(filePath);\n    return {\n      id: id,\n      name: path.basename(id),\n      originalName: path.basename(id),\n      size: stats.size,\n      compressedSize: stats.size,\n      type: \"application/octet-stream\",\n      folderId:\n        getRelativePath(path.dirname(filePath)) === \"root\"\n          ? null\n          : getRelativePath(path.dirname(filePath)),\n      createdAt: stats.birthtime,\n    };\n  } catch {\n    return undefined;\n  }\n}\n\nexport async function addFile(file: FileItem, buffer: Buffer): Promise<void> {\n  const folderPath = getAbsolutePath(file.folderId);\n  const filePath = path.join(folderPath, file.name);\n  await fs.writeFile(filePath, buffer);\n}\n\nexport async function deleteFile(id: string): Promise<boolean> {\n  try {\n    await fs.unlink(getAbsolutePath(id));\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function getFolders(\n  parentId: string | null = null\n): Promise<Folder[]> {\n  const dirPath = getAbsolutePath(parentId);\n\n  try {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\n    const folders: Folder[] = [];\n\n    for (const entry of entries) {\n      if (entry.isDirectory()) {\n        const stats = await fs.stat(path.join(dirPath, entry.name));\n        folders.push({\n          id: getRelativePath(path.join(dirPath, entry.name)),\n          name: entry.name,\n          parentId: parentId === \"root\" ? null : parentId,\n          createdAt: stats.birthtime,\n        });\n      }\n    }\n\n    return folders.sort((a, b) => a.name.localeCompare(b.name));\n  } catch (error) {\n    console.error(\"Error reading folders:\", error);\n    return [];\n  }\n}\n\nexport async function getFolder(id: string): Promise<Folder | undefined> {\n  const folderPath = getAbsolutePath(id);\n  try {\n    const stats = await fs.stat(folderPath);\n    if (!stats.isDirectory()) return undefined;\n\n    return {\n      id: id,\n      name: path.basename(id),\n      parentId:\n        getRelativePath(path.dirname(folderPath)) === \"root\"\n          ? null\n          : getRelativePath(path.dirname(folderPath)),\n      createdAt: stats.birthtime,\n    };\n  } catch {\n    return undefined;\n  }\n}\n\nexport async function addFolder(folder: Folder): Promise<void> {\n  const parentPath = getAbsolutePath(folder.parentId);\n  const folderPath = path.join(parentPath, folder.name);\n  await fs.mkdir(folderPath, { recursive: true });\n}\n\nexport async function deleteFolder(id: string): Promise<boolean> {\n  try {\n    await fs.rm(getAbsolutePath(id), { recursive: true, force: true });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function getBreadcrumbs(\n  folderId: string | null\n): Promise<Folder[]> {\n  const breadcrumbs: Folder[] = [];\n  if (!folderId || folderId === \"root\") return breadcrumbs;\n\n  let currentPath = folderId;\n\n  while (currentPath && currentPath !== \"root\") {\n    const folder = await getFolder(currentPath);\n    if (folder) {\n      breadcrumbs.unshift(folder);\n      // Move up one level\n      const parentDir = path.dirname(currentPath);\n      currentPath = parentDir === \".\" ? \"root\" : parentDir;\n    } else {\n      break;\n    }\n  }\n\n  return breadcrumbs;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"sources":["file:///home/deestarks/Desktop/landrop/app/api/files/%5Bid%5D/route.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from \"next/server\";\nimport { getFile, deleteFile } from \"@/lib/file-store\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: encodedId } = await params;\n    const id = decodeURIComponent(encodedId);\n    const file = await getFile(id);\n\n    if (!file) {\n      return NextResponse.json({ error: \"File not found\" }, { status: 404 });\n    }\n\n    // Read file directly from filesystem\n    const filePath = path.join(process.cwd(), \"uploads\", id);\n    const fileBuffer = await fs.readFile(filePath);\n\n    return new NextResponse(fileBuffer, {\n      headers: {\n        \"Content-Type\": file.type,\n        \"Content-Disposition\": `attachment; filename=\"${encodeURIComponent(\n          file.originalName\n        )}\"`,\n        \"Content-Length\": fileBuffer.length.toString(),\n      },\n    });\n  } catch (error) {\n    console.error(\"Error downloading file:\", error);\n    return NextResponse.json(\n      { error: \"Failed to download file\" },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  const { id: encodedId } = await params;\n  const id = decodeURIComponent(encodedId);\n  const success = await deleteFile(id);\n\n  if (!success) {\n    return NextResponse.json({ error: \"File not found\" }, { status: 404 });\n  }\n\n  return NextResponse.json({ success: true });\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAEO,eAAe,IACpB,OAAoB,EACpB,EAAE,MAAM,EAAuC;IAE/C,IAAI;QACF,MAAM,EAAE,IAAI,SAAS,EAAE,GAAG,MAAM;QAChC,MAAM,KAAK,mBAAmB;QAC9B,MAAM,OAAO,MAAM,IAAA,4IAAO,EAAC;QAE3B,IAAI,CAAC,MAAM;YACT,OAAO,2JAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAiB,GAAG;gBAAE,QAAQ;YAAI;QACtE;QAEA,qCAAqC;QACrC,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,WAAW;QACrD,MAAM,aAAa,MAAM,gIAAE,CAAC,QAAQ,CAAC;QAErC,OAAO,IAAI,2JAAY,CAAC,YAAY;YAClC,SAAS;gBACP,gBAAgB,KAAK,IAAI;gBACzB,uBAAuB,CAAC,sBAAsB,EAAE,mBAC9C,KAAK,YAAY,EACjB,CAAC,CAAC;gBACJ,kBAAkB,WAAW,MAAM,CAAC,QAAQ;YAC9C;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,2JAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA0B,GACnC;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,OACpB,OAAoB,EACpB,EAAE,MAAM,EAAuC;IAE/C,MAAM,EAAE,IAAI,SAAS,EAAE,GAAG,MAAM;IAChC,MAAM,KAAK,mBAAmB;IAC9B,MAAM,UAAU,MAAM,IAAA,+IAAU,EAAC;IAEjC,IAAI,CAAC,SAAS;QACZ,OAAO,2JAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAiB,GAAG;YAAE,QAAQ;QAAI;IACtE;IAEA,OAAO,2JAAY,CAAC,IAAI,CAAC;QAAE,SAAS;IAAK;AAC3C"}}]
}